doctype html
html
  head
    meta(charset='utf-8')
    meta(name='viewport', content='width=device-width, initial-scale=1, maximum-scale=1')
    title The two pillars of javascript

    link(rel='stylesheet', type='text/css', href='build/build.css')

  body

    article

      section(data-bespoke-backdrop='tasty')
        h1 TastyJS meetups

      section(data-bespoke-backdrop='me')
        h2 About me
        pre(class='code--medium')
          code.language-javascript.
            var author = {
              tito: {
                name: 'Augusto Altman Quaranta',
                worksAt: {
                    corp: 'Intel Corporation',
                    site: 'ASDC',
                    project: 'TrueKey'
                }
              };

      section(data-bespoke-backdrop='socialmedia')
        h4
          ul
            li
              span(style='color:orange') <a href="https://twitter.com/AugustoAltman">Twitter</a>
            li
              span(style='color:orange') <a href="https://github.com/augusto-altman">GitHub</a>
            li
              span(style='color:orange') <a href="https://www.npmjs.com/~augusto.altman">NPM</a>
            li
              span(style='color:orange') <a href="http://stackoverflow.com/users/3685148/augustoaltman">Stackoverflow</a>
            li
              span(style='color:orange') <a href="http://augustoaltman.tumblr.com/">blog</a>

      section(class='gif gif--nerd')

      section(data-bespoke-backdrop='pillars')
        h1 The two pillars of JavaSript

      section
        h3 Chapter 1

      section(data-bespoke-backdrop='darkcoding')
        h2 Hello darkness, my old friend. I've come to 
          span(style='color:orange') code 
          with you again.
        h3 <a href="https://www.youtube.com/watch?v=4zLfCnGVeL4">♫ Simon & Garfunkel - The sound of silence</a>

      section(data-bespoke-backdrop='jsrocks')
        h2 But do not misunderstand me, JavaScript rocks!

      section(data-bespoke-backdrop='versatile')
        h2
          span(style='color:orange') Because it's versatile
        h4
          ul
            li 
              span(style='color:lightblue') Functional.
            li 
              span(style='color:lightblue') Object oriented.
            li 
              span(style='color:lightblue') Event-based.
            li 
              span(style='color:lightblue') Procedural.

      section(data-bespoke-backdrop='dynamic')
        h2 Because it's dynamic
        h4
          ul
            li Weekly typed.
            li No classes.
            li Native late binding.
            li Not compiled.
            li Eval.

      section(data-bespoke-backdrop='opensource')
        h2 Because it's open source
        h4
          ul
            li Based on ECMAScript.
            li All the best engines, tools and libraries are open source.
            li Most used language on GitHub.
            li You can always check the source code.

      section(data-bespoke-backdrop='ubiquitous')
        h2 Because it's ubiquitous and universal
        h4
          ul
            li Standar language for web aplications.
            li All software is becoming web software.
            li Node.JS and io.js are taking over the server side.
            li Npm is the largest programming language package repository.
            li Available also for embeded systems.

      section(data-bespoke-backdrop='youshouldlearnjs')
        h2 You should be learning JavaScript right now.

      section(data-bespoke-backdrop='theproblem')
        h2 The problem isn't JavaScript.
        h3 The problem is the way people learn it.

      section(data-bespoke-backdrop='noideadog')
        h2 The reallity
        h3 Almost everybody knows a little JavaScript, but almost nobody really understands JavaScript.

      section(class='gif gif--noidea')

      section(data-bespoke-backdrop='ericelliot')
        h4 99 out of 100 JavaScript developers I interview lack the skills required to hit the ground running on a scalable production JavaScript application.
        h3 Eric Elliot.

      section(data-bespoke-backdrop='yaoming')
        h4 The fact is, most of the world’s software infrastructure is heavily dependent on JavaScript: perhaps the world’s most misunderstood programming language.
        h3 Eric Elliot.

      section
        h3 Chapter 2

      section(data-bespoke-backdrop='everywhere')
        h2 Closures, closures everywhere.
        h3 First pillar.

      section(data-bespoke-backdrop='madbaby')
        h2 Everybody should clearly understand closures!!
        h3 They enable state encapsulation and therefore are part of the language foundations.

      section(data-bespoke-backdrop='twofingers')
        h2 There are two key concepts around closures:
        h4
          ul
            li First-class functions.
            li Function lexical scope.

      section(data-bespoke-backdrop='firstclassplane')
        h2 First-class functions.

      section(data-bespoke-backdrop='firstclass')
        h2 A first-class function is one that may participate as a normal data
        h3 i.e. be created literally at runtime, be passed as an argument, or be returned as a value from another function.

      section
        pre(class='code--medium')
          code.language-javascript.
            function someFun() {
              console.log('lalala');
            }

            function someOtherFunc(callback) {
              callback();
            }

            someOtherfunc(someFunc);

      section(data-bespoke-backdrop='lexical')
        h2 Lexical scopes.

      section(class='gif gif--fight')
        h4 For the sake conceptual clearity.
        h2 Context vs Scope

      section(data-bespoke-backdrop='scientiscat')
        h3 Every function invocation has both a scope and a context associated with it.
        h4
          ul
            li Scope pertains to the variable access of the function when it is invoked.
            li Context is always the value of the this keyword.

      section(data-bespoke-backdrop='yingyang')
        h3 In general programming language theory, scopes can be nested at any block level.
        h2 Types of nested scopes.
        h4
          ul
            li Lexical scopes, e.g: C, C++, JavaScript
            li Dynamic scopes, e.g: Ruby

      section(data-bespoke-backdrop='chucknorrisapproves')
        h2 JavaScript allows scope nesting at function level. 
        h3 Functions are lexical scoped in JavaScript.

      section(data-bespoke-backdrop='lexicalscopes')

      section(class='gif gif--boring')
        h4 Lexical scope is the concept, and JavaScript implements it via the scope chain.
        h3 A function has access to the variables present in their outer enclosing functions.

      section(data-bespoke-backdrop='scopechain')

      section(data-bespoke-backdrop='closure')
        h2 Closures

      section(data-bespoke-backdrop='thinking')
        h3 Whenever a function is treated as data it must mantain its scope chain.
        h4 i.e. when we pass a function reference as an argument we are also passing its scope chain so it can be executed later maintaining its lexical scope.

      section(data-bespoke-backdrop='awesome')
        h2 And that's what a closure is!
        h3 Formally speaking: A closure is a pair consisting of the function code and the environment in which the function is created (its lexical scopes).

      section
        pre(class='code--medium')
          code.language-javascript.
            function funcFactory() {
              var name = "tito";
              function showName() {
                console.log(name);
              }
              return showName;
            }

            var aFunc = funcFactory();
            aFunc();

      section(data-bespoke-backdrop='enlightened')
        h3 Like objects, closures are a mechanism for containing state. But only encapsulated state..
        h4 So it's a means for encapsulation.

      section(data-bespoke-backdrop='factory')
        h2 A great example of how closures provides encapsulation is the 
          span(style='color:orange') factory constructor function pattern.
        h3 <a href="http://javascript.info/tutorial/factory-constructor-pattern">From javascript.info patterns repository.</a>

      section
        pre(class='code--small')
          code.language-javascript.
            function Person(newPersonName, newPersonDeathAge) { //factory constructor function
              var name = newPersonName || 'tito';
              var deathAge = newPersonDeathAge || 80;
              var age = 0;
              return {
                reName: function (newName){
                  name = newName;
                },
                getName: function (){
                  return name;
                },
                happyBithday: function () {
                  if(this.isAlive())
                    age++;
                },
                getAge: function () {
                  return age;
                },
                isAlive: function () {
                  return this.getAge() < deathAge;
                }
              };
            }

      section
        pre(class='code--medium')
          code.language-javascript.
            var josePerez = Person('jose', 30);
            var juanRodriguez = Person('juan');

            for(var i = 0; i<20; i++){
              josePerez.happyBithday();
            }
            juanRodriguez.happyBithday();
            juanRodriguez.happyBithday();

            console.log(josePerez.getAge()); //20
            console.log(juanRodriguez.getAge()); //2

      section(data-bespoke-backdrop='coolcat')
        h3 Encapsulation through closures can also be exploited to:
        h4
          ul
            li Propagate state through async calls.
            li Create namespaces.

      section(data-bespoke-backdrop='statepropagation')
        h2 Async state propagation.
        h3 Callbacks.

      section
        pre(class='code--small')
          code.language-javascript.
            function TimeTalker(newMaxTime, newPhrase) {
              var maxTime = newMaxTime || 30;
              var phrase = newPhrase || 'soyet le tito';
              var interval;
              var counter = 0;
              return {
                start: function () {
                  interval = setInterval(function callback(){
                    console.log(phrase);
                    counter++;
                    if(counter >= maxTime) {
                      clearInterval(interval);
                    }
                  }, 1000);
                }
              };
            }

            var aTalker = TimeTalker(5, 'closures are awesome');
            aTalker.start();

      section(data-bespoke-backdrop='carcrash')
        h2 Namespace creation.
        h3 Avoiding name crashes.

      section(data-bespoke-backdrop='crockford')
        h2 A great example of how closures provides namespacing is the 
          span(style='color:orange') module pattern.
        h3 Popularized by Douglas Crockford

      section
        pre(class='code--small')
          code.language-javascript.
            var someVar = 'San Lorenzo de Almagro';
            console.log(someVar); //San Lorenzo de Almagro

            var Module = (function () { //IIFE
              var someVar = 'walla walla';
              var someOtherVar;
              console.log(someVar); //walla walla
              return function() {
                //doSomething
              };
            })();

            console.log(someVar); //San Lorenzo de Almagro

      section
        h3 Chapter 3

      section(data-bespoke-backdrop='prototype')
        h2 Prototypal inheritance.
        h3 Second pillar.

      section(data-bespoke-backdrop='madbaby')
        h2 Everybody should clearly understand prototypal inheritance!!
        h3 They enable code re-utilization and therefore are part of the language foundations.

      section(data-bespoke-backdrop='evolution')
        h3 In prototypal inheritance, instances inherit from other instances.

      section(data-bespoke-backdrop='cooldog')
        h2 The prototypal inheritance model is more powerful than the classic model.
        h6 It is fairly trivial to build a classic model on top of a prototypal model, while the other way around is a far more difficult task.
        h3 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Inheritance_and_the_prototype_chain">Mozilla</a>

      section(data-bespoke-backdrop='three')
        h3 There are three kinds of Prototypal inheritance.
        h4 
          ul
            li Delegative inheritance.
            li Concatenative inheritance.
            li Functional inheritance. (Identified by Douglas Crockford).
        h4 And the three of them are supported by JavaScript.

      section(data-bespoke-backdrop='delegation')
        h2 Delegative inheritance.

      section(data-bespoke-backdrop='nerd')
        h2 A delegate prototype is an object that serves as a base for another object.
        h4 The language is resposible of dispatching the correct method or finding the right piece of data simply by following a series of delegation pointers (from object to its prototype) until a match is found.

      section(data-bespoke-backdrop='dafuck')
        h3 JavaScript provides natively delegation inheritance through the prototype chain mechanism.
      
      section(data-bespoke-backdrop='prototype-chain')

      section(data-bespoke-backdrop='relaxedhomer')
        h4 There are two well-known ways of stablishing delegate prototypes:
        h4
          ul
            li Through the constructor pattern.
            li Through Object.create().

      section(data-bespoke-backdrop='constructor')
        h2 The constructor pattern

      section
        pre(class='code--medium')
          code.language-javascript.
            function Greeter(name) {
              this.name = name || 'John Doe';
            }
            
            Greeter.prototype.hello = function hello() {
              return 'Hello, my name is ' + this.name;
            };
            
            var george = new Greeter('George');

      section(data-bespoke-backdrop='god')
        h2 Object.create()

      section
        pre(class='code--medium')
          code.language-javascript.
            var proto = {
              hello: function hello() {
                return 'Hello, my name is ' + this.name;
              }
            };
             
            var george = Object.create(proto);
            george.name = 'George';

      section(data-bespoke-backdrop='question')
        h2 Why delegation matters?
        h4
          ul
            li Method delegation is a fantastic way to preserve memory resources.
            li It’s a great way to add capabilities at runtime to all objects which share a particular prototype.

      section(data-bespoke-backdrop='homerclon')
        h2 Concatenative inheritance.
        h3 Prototype cloning.

      section(data-bespoke-backdrop='nerd')
        h4 Prototype cloning is the process of copying the properties from one object to another, without retaining a reference between the two objects.

      section(data-bespoke-backdrop='somuchwin')
        h2 JavaScript allows dynamic object extension.
        h3 So any object strcutre can be changed in runtime by adding or removing properties, which can't be done in the classical model.

      section
        pre(class='code--medium')
          code.language-javascript.
            var proto = {
              hello: function hello() {
                return 'Hello, my name is ' + this.name;
              }
            };
            
            //We are using the extend fuction from underscore.
            var george = _.extend({}, proto, {name: 'George'});

      section(data-bespoke-backdrop='question')
        h2 Why concatenation matters?
        h4
          ul
            li Cloning is a great way to store default state for objects.
            li Property access is faster because inherited properties are copied.
            li Objects may copy properties from any number of prototypes (composition).
            li It enables behavior extension patterns like mixins.

      section(data-bespoke-backdrop='scrat')
        h2 Functional inheritance.
        h3 Closure prototypes.

      section(data-bespoke-backdrop='nerd')
        h4 Closure prototypes are functions that can be run against a target object in order to extend it.
        h3 They can hold encapsulated state and extend the new objects in order to they can hold it too.

      section
        pre(class='code--small')
          code.language-javascript.
            var PersonModel = function (personAge, personOccupation) {
              var age = personAge || 0;
              var occupation = personOccupation || 'none';
             
              this.getOccupation = function () {
                return occupation;
              };

              this.getAge = function () {
                return age;
              };

              this.happyBirthday = function () {
                age++;
              };
            };

            var george = {
              name: 'George'
            };

            PersonModel.call(george, 13, 'student');

            console.log(george.name); //George
            console.log(george.getAge()); //13

      section(data-bespoke-backdrop='question')
        h2 Why closure prototypes matters?
        h4
          ul
            li It enables objects to be extended with encapsulated state.

      section
        h3 Final thoughts

      section(class='gif gif--cry')

      section(data-bespoke-backdrop='advice')
        h2 Some advices.
        h4
          ul
            li Favor composition over inheritance.
            li Favor the usage of factory constructor functions.
            li Read and learn JavaScript patterns for object creation and inheritance.
            li Read and learn about good and bad practices in JavaScript.
            li Use libraries that reduce the complexity of combining patterns and techniques (like stampit).

      section(data-bespoke-backdrop='takeaways')
        h2 Takeaways.
        h4
          ul
            li JavaScript cannot be properly learnt with the classical mindset.
            li The mechanism for providing code re-utilization and state encapsulation are always at a foundation level of any language.

      section(class='gif gif--thanks')

    script(src='build/build.js')